// Code generated by gotdgen, DO NOT EDIT.

package tdapi

import (
	"context"
	"errors"
	"fmt"
	"sort"
	"strings"

	"go.uber.org/multierr"

	"github.com/gotd/td/bin"
	"github.com/gotd/td/tdjson"
	"github.com/gotd/td/tdp"
	"github.com/gotd/td/tgerr"
)

// No-op definition for keeping imports.
var (
	_ = bin.Buffer{}
	_ = context.Background()
	_ = fmt.Stringer(nil)
	_ = strings.Builder{}
	_ = errors.Is
	_ = multierr.AppendInto
	_ = sort.Ints
	_ = tdp.Format
	_ = tgerr.Error{}
	_ = tdjson.Encoder{}
)

// Message represents TL type `message#e285e28a`.
type Message struct {
	// Message identifier; unique for the chat to which the message belongs
	ID int64
	// Identifier of the sender of the message
	SenderID MessageSenderClass
	// Chat identifier
	ChatID int64
	// The sending state of the message; may be null if the message isn't being sent and
	// didn't fail to be sent
	SendingState MessageSendingStateClass
	// The scheduling state of the message; may be null if the message isn't scheduled
	SchedulingState MessageSchedulingStateClass
	// True, if the message is outgoing
	IsOutgoing bool
	// True, if the message is pinned
	IsPinned bool
	// True, if the message can be edited. For live location and poll messages this fields
	// shows whether editMessageLiveLocation or stopPoll can be used with this message by the
	// application
	CanBeEdited bool
	// True, if the message can be forwarded
	CanBeForwarded bool
	// True, if content of the message can be saved locally or copied
	CanBeSaved bool
	// True, if the message can be deleted only for the current user while other users will
	// continue to see it
	CanBeDeletedOnlyForSelf bool
	// True, if the message can be deleted for all users
	CanBeDeletedForAllUsers bool
	// True, if the list of added reactions is available through getMessageAddedReactions
	CanGetAddedReactions bool
	// True, if the message statistics are available through getMessageStatistics
	CanGetStatistics bool
	// True, if information about the message thread is available through getMessageThread
	// and getMessageThreadHistory
	CanGetMessageThread bool
	// True, if chat members already viewed the message can be received through
	// getMessageViewers
	CanGetViewers bool
	// True, if media timestamp links can be generated for media timestamp entities in the
	// message text, caption or web page description through getMessageLink
	CanGetMediaTimestampLinks bool
	// True, if reactions on the message can be reported through reportMessageReactions
	CanReportReactions bool
	// True, if media timestamp entities refers to a media in this message as opposed to a
	// media in the replied message
	HasTimestampedMedia bool
	// True, if the message is a channel post. All messages to channels are channel posts,
	// all other messages are not channel posts
	IsChannelPost bool
	// True, if the message is a forum topic message
	IsTopicMessage bool
	// True, if the message contains an unread mention for the current user
	ContainsUnreadMention bool
	// Point in time (Unix timestamp) when the message was sent
	Date int32
	// Point in time (Unix timestamp) when the message was last edited
	EditDate int32
	// Information about the initial message sender; may be null if none or unknown
	ForwardInfo MessageForwardInfo
	// Information about interactions with the message; may be null if none
	InteractionInfo MessageInteractionInfo
	// Information about unread reactions added to the message
	UnreadReactions []UnreadReaction
	// Information about the message or the story this message is replying to; may be null if
	// none
	ReplyTo MessageReplyToClass
	// If non-zero, the identifier of the message thread the message belongs to; unique
	// within the chat to which the message belongs
	MessageThreadID int64
	// The message's self-destruct time, in seconds; 0 if none. TDLib will send
	// updateDeleteMessages or updateMessageContent once the time expires
	SelfDestructTime int32
	// Time left before the message self-destruct timer expires, in seconds. If the
	// self-destruct timer isn't started yet, equals to the value of the self_destruct_time
	// field
	SelfDestructIn float64
	// Time left before the message will be automatically deleted by message_auto_delete_time
	// setting of the chat, in seconds; 0 if never. TDLib will send updateDeleteMessages or
	// updateMessageContent once the time expires
	AutoDeleteIn float64
	// If non-zero, the user identifier of the bot through which this message was sent
	ViaBotUserID int64
	// For channel posts and anonymous group messages, optional author signature
	AuthorSignature string
	// Unique identifier of an album this message belongs to. Only audios, documents, photos
	// and videos can be grouped together in albums
	MediaAlbumID int64
	// If non-empty, contains a human-readable description of the reason why access to this
	// message must be restricted
	RestrictionReason string
	// Content of the message
	Content MessageContentClass
	// Reply markup for the message; may be null if none
	ReplyMarkup ReplyMarkupClass
}

// MessageTypeID is TL type id of Message.
const MessageTypeID = 0xe285e28a

// Ensuring interfaces in compile-time for Message.
var (
	_ bin.Encoder     = &Message{}
	_ bin.Decoder     = &Message{}
	_ bin.BareEncoder = &Message{}
	_ bin.BareDecoder = &Message{}
)

func (m *Message) Zero() bool {
	if m == nil {
		return true
	}
	if !(m.ID == 0) {
		return false
	}
	if !(m.SenderID == nil) {
		return false
	}
	if !(m.ChatID == 0) {
		return false
	}
	if !(m.SendingState == nil) {
		return false
	}
	if !(m.SchedulingState == nil) {
		return false
	}
	if !(m.IsOutgoing == false) {
		return false
	}
	if !(m.IsPinned == false) {
		return false
	}
	if !(m.CanBeEdited == false) {
		return false
	}
	if !(m.CanBeForwarded == false) {
		return false
	}
	if !(m.CanBeSaved == false) {
		return false
	}
	if !(m.CanBeDeletedOnlyForSelf == false) {
		return false
	}
	if !(m.CanBeDeletedForAllUsers == false) {
		return false
	}
	if !(m.CanGetAddedReactions == false) {
		return false
	}
	if !(m.CanGetStatistics == false) {
		return false
	}
	if !(m.CanGetMessageThread == false) {
		return false
	}
	if !(m.CanGetViewers == false) {
		return false
	}
	if !(m.CanGetMediaTimestampLinks == false) {
		return false
	}
	if !(m.CanReportReactions == false) {
		return false
	}
	if !(m.HasTimestampedMedia == false) {
		return false
	}
	if !(m.IsChannelPost == false) {
		return false
	}
	if !(m.IsTopicMessage == false) {
		return false
	}
	if !(m.ContainsUnreadMention == false) {
		return false
	}
	if !(m.Date == 0) {
		return false
	}
	if !(m.EditDate == 0) {
		return false
	}
	if !(m.ForwardInfo.Zero()) {
		return false
	}
	if !(m.InteractionInfo.Zero()) {
		return false
	}
	if !(m.UnreadReactions == nil) {
		return false
	}
	if !(m.ReplyTo == nil) {
		return false
	}
	if !(m.MessageThreadID == 0) {
		return false
	}
	if !(m.SelfDestructTime == 0) {
		return false
	}
	if !(m.SelfDestructIn == 0) {
		return false
	}
	if !(m.AutoDeleteIn == 0) {
		return false
	}
	if !(m.ViaBotUserID == 0) {
		return false
	}
	if !(m.AuthorSignature == "") {
		return false
	}
	if !(m.MediaAlbumID == 0) {
		return false
	}
	if !(m.RestrictionReason == "") {
		return false
	}
	if !(m.Content == nil) {
		return false
	}
	if !(m.ReplyMarkup == nil) {
		return false
	}

	return true
}

// String implements fmt.Stringer.
func (m *Message) String() string {
	if m == nil {
		return "Message(nil)"
	}
	type Alias Message
	return fmt.Sprintf("Message%+v", Alias(*m))
}

// TypeID returns type id in TL schema.
//
// See https://core.telegram.org/mtproto/TL-tl#remarks.
func (*Message) TypeID() uint32 {
	return MessageTypeID
}

// TypeName returns name of type in TL schema.
func (*Message) TypeName() string {
	return "message"
}

// TypeInfo returns info about TL type.
func (m *Message) TypeInfo() tdp.Type {
	typ := tdp.Type{
		Name: "message",
		ID:   MessageTypeID,
	}
	if m == nil {
		typ.Null = true
		return typ
	}
	typ.Fields = []tdp.Field{
		{
			Name:       "ID",
			SchemaName: "id",
		},
		{
			Name:       "SenderID",
			SchemaName: "sender_id",
		},
		{
			Name:       "ChatID",
			SchemaName: "chat_id",
		},
		{
			Name:       "SendingState",
			SchemaName: "sending_state",
		},
		{
			Name:       "SchedulingState",
			SchemaName: "scheduling_state",
		},
		{
			Name:       "IsOutgoing",
			SchemaName: "is_outgoing",
		},
		{
			Name:       "IsPinned",
			SchemaName: "is_pinned",
		},
		{
			Name:       "CanBeEdited",
			SchemaName: "can_be_edited",
		},
		{
			Name:       "CanBeForwarded",
			SchemaName: "can_be_forwarded",
		},
		{
			Name:       "CanBeSaved",
			SchemaName: "can_be_saved",
		},
		{
			Name:       "CanBeDeletedOnlyForSelf",
			SchemaName: "can_be_deleted_only_for_self",
		},
		{
			Name:       "CanBeDeletedForAllUsers",
			SchemaName: "can_be_deleted_for_all_users",
		},
		{
			Name:       "CanGetAddedReactions",
			SchemaName: "can_get_added_reactions",
		},
		{
			Name:       "CanGetStatistics",
			SchemaName: "can_get_statistics",
		},
		{
			Name:       "CanGetMessageThread",
			SchemaName: "can_get_message_thread",
		},
		{
			Name:       "CanGetViewers",
			SchemaName: "can_get_viewers",
		},
		{
			Name:       "CanGetMediaTimestampLinks",
			SchemaName: "can_get_media_timestamp_links",
		},
		{
			Name:       "CanReportReactions",
			SchemaName: "can_report_reactions",
		},
		{
			Name:       "HasTimestampedMedia",
			SchemaName: "has_timestamped_media",
		},
		{
			Name:       "IsChannelPost",
			SchemaName: "is_channel_post",
		},
		{
			Name:       "IsTopicMessage",
			SchemaName: "is_topic_message",
		},
		{
			Name:       "ContainsUnreadMention",
			SchemaName: "contains_unread_mention",
		},
		{
			Name:       "Date",
			SchemaName: "date",
		},
		{
			Name:       "EditDate",
			SchemaName: "edit_date",
		},
		{
			Name:       "ForwardInfo",
			SchemaName: "forward_info",
		},
		{
			Name:       "InteractionInfo",
			SchemaName: "interaction_info",
		},
		{
			Name:       "UnreadReactions",
			SchemaName: "unread_reactions",
		},
		{
			Name:       "ReplyTo",
			SchemaName: "reply_to",
		},
		{
			Name:       "MessageThreadID",
			SchemaName: "message_thread_id",
		},
		{
			Name:       "SelfDestructTime",
			SchemaName: "self_destruct_time",
		},
		{
			Name:       "SelfDestructIn",
			SchemaName: "self_destruct_in",
		},
		{
			Name:       "AutoDeleteIn",
			SchemaName: "auto_delete_in",
		},
		{
			Name:       "ViaBotUserID",
			SchemaName: "via_bot_user_id",
		},
		{
			Name:       "AuthorSignature",
			SchemaName: "author_signature",
		},
		{
			Name:       "MediaAlbumID",
			SchemaName: "media_album_id",
		},
		{
			Name:       "RestrictionReason",
			SchemaName: "restriction_reason",
		},
		{
			Name:       "Content",
			SchemaName: "content",
		},
		{
			Name:       "ReplyMarkup",
			SchemaName: "reply_markup",
		},
	}
	return typ
}

// Encode implements bin.Encoder.
func (m *Message) Encode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode message#e285e28a as nil")
	}
	b.PutID(MessageTypeID)
	return m.EncodeBare(b)
}

// EncodeBare implements bin.BareEncoder.
func (m *Message) EncodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't encode message#e285e28a as nil")
	}
	b.PutInt53(m.ID)
	if m.SenderID == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field sender_id is nil")
	}
	if err := m.SenderID.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field sender_id: %w", err)
	}
	b.PutInt53(m.ChatID)
	if m.SendingState == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field sending_state is nil")
	}
	if err := m.SendingState.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field sending_state: %w", err)
	}
	if m.SchedulingState == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field scheduling_state is nil")
	}
	if err := m.SchedulingState.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field scheduling_state: %w", err)
	}
	b.PutBool(m.IsOutgoing)
	b.PutBool(m.IsPinned)
	b.PutBool(m.CanBeEdited)
	b.PutBool(m.CanBeForwarded)
	b.PutBool(m.CanBeSaved)
	b.PutBool(m.CanBeDeletedOnlyForSelf)
	b.PutBool(m.CanBeDeletedForAllUsers)
	b.PutBool(m.CanGetAddedReactions)
	b.PutBool(m.CanGetStatistics)
	b.PutBool(m.CanGetMessageThread)
	b.PutBool(m.CanGetViewers)
	b.PutBool(m.CanGetMediaTimestampLinks)
	b.PutBool(m.CanReportReactions)
	b.PutBool(m.HasTimestampedMedia)
	b.PutBool(m.IsChannelPost)
	b.PutBool(m.IsTopicMessage)
	b.PutBool(m.ContainsUnreadMention)
	b.PutInt32(m.Date)
	b.PutInt32(m.EditDate)
	if err := m.ForwardInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field forward_info: %w", err)
	}
	if err := m.InteractionInfo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field interaction_info: %w", err)
	}
	b.PutInt(len(m.UnreadReactions))
	for idx, v := range m.UnreadReactions {
		if err := v.EncodeBare(b); err != nil {
			return fmt.Errorf("unable to encode bare message#e285e28a: field unread_reactions element with index %d: %w", idx, err)
		}
	}
	if m.ReplyTo == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field reply_to is nil")
	}
	if err := m.ReplyTo.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field reply_to: %w", err)
	}
	b.PutInt53(m.MessageThreadID)
	b.PutInt32(m.SelfDestructTime)
	b.PutDouble(m.SelfDestructIn)
	b.PutDouble(m.AutoDeleteIn)
	b.PutInt53(m.ViaBotUserID)
	b.PutString(m.AuthorSignature)
	b.PutLong(m.MediaAlbumID)
	b.PutString(m.RestrictionReason)
	if m.Content == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field content is nil")
	}
	if err := m.Content.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field content: %w", err)
	}
	if m.ReplyMarkup == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field reply_markup is nil")
	}
	if err := m.ReplyMarkup.Encode(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field reply_markup: %w", err)
	}
	return nil
}

// Decode implements bin.Decoder.
func (m *Message) Decode(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode message#e285e28a to nil")
	}
	if err := b.ConsumeID(MessageTypeID); err != nil {
		return fmt.Errorf("unable to decode message#e285e28a: %w", err)
	}
	return m.DecodeBare(b)
}

// DecodeBare implements bin.BareDecoder.
func (m *Message) DecodeBare(b *bin.Buffer) error {
	if m == nil {
		return fmt.Errorf("can't decode message#e285e28a to nil")
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field id: %w", err)
		}
		m.ID = value
	}
	{
		value, err := DecodeMessageSender(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field sender_id: %w", err)
		}
		m.SenderID = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field chat_id: %w", err)
		}
		m.ChatID = value
	}
	{
		value, err := DecodeMessageSendingState(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field sending_state: %w", err)
		}
		m.SendingState = value
	}
	{
		value, err := DecodeMessageSchedulingState(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field scheduling_state: %w", err)
		}
		m.SchedulingState = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field is_outgoing: %w", err)
		}
		m.IsOutgoing = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field is_pinned: %w", err)
		}
		m.IsPinned = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_be_edited: %w", err)
		}
		m.CanBeEdited = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_be_forwarded: %w", err)
		}
		m.CanBeForwarded = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_be_saved: %w", err)
		}
		m.CanBeSaved = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_be_deleted_only_for_self: %w", err)
		}
		m.CanBeDeletedOnlyForSelf = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_be_deleted_for_all_users: %w", err)
		}
		m.CanBeDeletedForAllUsers = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_get_added_reactions: %w", err)
		}
		m.CanGetAddedReactions = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_get_statistics: %w", err)
		}
		m.CanGetStatistics = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_get_message_thread: %w", err)
		}
		m.CanGetMessageThread = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_get_viewers: %w", err)
		}
		m.CanGetViewers = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_get_media_timestamp_links: %w", err)
		}
		m.CanGetMediaTimestampLinks = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field can_report_reactions: %w", err)
		}
		m.CanReportReactions = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field has_timestamped_media: %w", err)
		}
		m.HasTimestampedMedia = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field is_channel_post: %w", err)
		}
		m.IsChannelPost = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field is_topic_message: %w", err)
		}
		m.IsTopicMessage = value
	}
	{
		value, err := b.Bool()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field contains_unread_mention: %w", err)
		}
		m.ContainsUnreadMention = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field date: %w", err)
		}
		m.Date = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field edit_date: %w", err)
		}
		m.EditDate = value
	}
	{
		if err := m.ForwardInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field forward_info: %w", err)
		}
	}
	{
		if err := m.InteractionInfo.Decode(b); err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field interaction_info: %w", err)
		}
	}
	{
		headerLen, err := b.Int()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field unread_reactions: %w", err)
		}

		if headerLen > 0 {
			m.UnreadReactions = make([]UnreadReaction, 0, headerLen%bin.PreallocateLimit)
		}
		for idx := 0; idx < headerLen; idx++ {
			var value UnreadReaction
			if err := value.DecodeBare(b); err != nil {
				return fmt.Errorf("unable to decode bare message#e285e28a: field unread_reactions: %w", err)
			}
			m.UnreadReactions = append(m.UnreadReactions, value)
		}
	}
	{
		value, err := DecodeMessageReplyTo(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field reply_to: %w", err)
		}
		m.ReplyTo = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field message_thread_id: %w", err)
		}
		m.MessageThreadID = value
	}
	{
		value, err := b.Int32()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field self_destruct_time: %w", err)
		}
		m.SelfDestructTime = value
	}
	{
		value, err := b.Double()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field self_destruct_in: %w", err)
		}
		m.SelfDestructIn = value
	}
	{
		value, err := b.Double()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field auto_delete_in: %w", err)
		}
		m.AutoDeleteIn = value
	}
	{
		value, err := b.Int53()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field via_bot_user_id: %w", err)
		}
		m.ViaBotUserID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field author_signature: %w", err)
		}
		m.AuthorSignature = value
	}
	{
		value, err := b.Long()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field media_album_id: %w", err)
		}
		m.MediaAlbumID = value
	}
	{
		value, err := b.String()
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field restriction_reason: %w", err)
		}
		m.RestrictionReason = value
	}
	{
		value, err := DecodeMessageContent(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field content: %w", err)
		}
		m.Content = value
	}
	{
		value, err := DecodeReplyMarkup(b)
		if err != nil {
			return fmt.Errorf("unable to decode message#e285e28a: field reply_markup: %w", err)
		}
		m.ReplyMarkup = value
	}
	return nil
}

// EncodeTDLibJSON implements tdjson.TDLibEncoder.
func (m *Message) EncodeTDLibJSON(b tdjson.Encoder) error {
	if m == nil {
		return fmt.Errorf("can't encode message#e285e28a as nil")
	}
	b.ObjStart()
	b.PutID("message")
	b.Comma()
	b.FieldStart("id")
	b.PutInt53(m.ID)
	b.Comma()
	b.FieldStart("sender_id")
	if m.SenderID == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field sender_id is nil")
	}
	if err := m.SenderID.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field sender_id: %w", err)
	}
	b.Comma()
	b.FieldStart("chat_id")
	b.PutInt53(m.ChatID)
	b.Comma()
	b.FieldStart("sending_state")
	if m.SendingState == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field sending_state is nil")
	}
	if err := m.SendingState.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field sending_state: %w", err)
	}
	b.Comma()
	b.FieldStart("scheduling_state")
	if m.SchedulingState == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field scheduling_state is nil")
	}
	if err := m.SchedulingState.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field scheduling_state: %w", err)
	}
	b.Comma()
	b.FieldStart("is_outgoing")
	b.PutBool(m.IsOutgoing)
	b.Comma()
	b.FieldStart("is_pinned")
	b.PutBool(m.IsPinned)
	b.Comma()
	b.FieldStart("can_be_edited")
	b.PutBool(m.CanBeEdited)
	b.Comma()
	b.FieldStart("can_be_forwarded")
	b.PutBool(m.CanBeForwarded)
	b.Comma()
	b.FieldStart("can_be_saved")
	b.PutBool(m.CanBeSaved)
	b.Comma()
	b.FieldStart("can_be_deleted_only_for_self")
	b.PutBool(m.CanBeDeletedOnlyForSelf)
	b.Comma()
	b.FieldStart("can_be_deleted_for_all_users")
	b.PutBool(m.CanBeDeletedForAllUsers)
	b.Comma()
	b.FieldStart("can_get_added_reactions")
	b.PutBool(m.CanGetAddedReactions)
	b.Comma()
	b.FieldStart("can_get_statistics")
	b.PutBool(m.CanGetStatistics)
	b.Comma()
	b.FieldStart("can_get_message_thread")
	b.PutBool(m.CanGetMessageThread)
	b.Comma()
	b.FieldStart("can_get_viewers")
	b.PutBool(m.CanGetViewers)
	b.Comma()
	b.FieldStart("can_get_media_timestamp_links")
	b.PutBool(m.CanGetMediaTimestampLinks)
	b.Comma()
	b.FieldStart("can_report_reactions")
	b.PutBool(m.CanReportReactions)
	b.Comma()
	b.FieldStart("has_timestamped_media")
	b.PutBool(m.HasTimestampedMedia)
	b.Comma()
	b.FieldStart("is_channel_post")
	b.PutBool(m.IsChannelPost)
	b.Comma()
	b.FieldStart("is_topic_message")
	b.PutBool(m.IsTopicMessage)
	b.Comma()
	b.FieldStart("contains_unread_mention")
	b.PutBool(m.ContainsUnreadMention)
	b.Comma()
	b.FieldStart("date")
	b.PutInt32(m.Date)
	b.Comma()
	b.FieldStart("edit_date")
	b.PutInt32(m.EditDate)
	b.Comma()
	b.FieldStart("forward_info")
	if err := m.ForwardInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field forward_info: %w", err)
	}
	b.Comma()
	b.FieldStart("interaction_info")
	if err := m.InteractionInfo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field interaction_info: %w", err)
	}
	b.Comma()
	b.FieldStart("unread_reactions")
	b.ArrStart()
	for idx, v := range m.UnreadReactions {
		if err := v.EncodeTDLibJSON(b); err != nil {
			return fmt.Errorf("unable to encode message#e285e28a: field unread_reactions element with index %d: %w", idx, err)
		}
		b.Comma()
	}
	b.StripComma()
	b.ArrEnd()
	b.Comma()
	b.FieldStart("reply_to")
	if m.ReplyTo == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field reply_to is nil")
	}
	if err := m.ReplyTo.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field reply_to: %w", err)
	}
	b.Comma()
	b.FieldStart("message_thread_id")
	b.PutInt53(m.MessageThreadID)
	b.Comma()
	b.FieldStart("self_destruct_time")
	b.PutInt32(m.SelfDestructTime)
	b.Comma()
	b.FieldStart("self_destruct_in")
	b.PutDouble(m.SelfDestructIn)
	b.Comma()
	b.FieldStart("auto_delete_in")
	b.PutDouble(m.AutoDeleteIn)
	b.Comma()
	b.FieldStart("via_bot_user_id")
	b.PutInt53(m.ViaBotUserID)
	b.Comma()
	b.FieldStart("author_signature")
	b.PutString(m.AuthorSignature)
	b.Comma()
	b.FieldStart("media_album_id")
	b.PutLong(m.MediaAlbumID)
	b.Comma()
	b.FieldStart("restriction_reason")
	b.PutString(m.RestrictionReason)
	b.Comma()
	b.FieldStart("content")
	if m.Content == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field content is nil")
	}
	if err := m.Content.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field content: %w", err)
	}
	b.Comma()
	b.FieldStart("reply_markup")
	if m.ReplyMarkup == nil {
		return fmt.Errorf("unable to encode message#e285e28a: field reply_markup is nil")
	}
	if err := m.ReplyMarkup.EncodeTDLibJSON(b); err != nil {
		return fmt.Errorf("unable to encode message#e285e28a: field reply_markup: %w", err)
	}
	b.Comma()
	b.StripComma()
	b.ObjEnd()
	return nil
}

// DecodeTDLibJSON implements tdjson.TDLibDecoder.
func (m *Message) DecodeTDLibJSON(b tdjson.Decoder) error {
	if m == nil {
		return fmt.Errorf("can't decode message#e285e28a to nil")
	}

	return b.Obj(func(b tdjson.Decoder, key []byte) error {
		switch string(key) {
		case tdjson.TypeField:
			if err := b.ConsumeID("message"); err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: %w", err)
			}
		case "id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field id: %w", err)
			}
			m.ID = value
		case "sender_id":
			value, err := DecodeTDLibJSONMessageSender(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field sender_id: %w", err)
			}
			m.SenderID = value
		case "chat_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field chat_id: %w", err)
			}
			m.ChatID = value
		case "sending_state":
			value, err := DecodeTDLibJSONMessageSendingState(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field sending_state: %w", err)
			}
			m.SendingState = value
		case "scheduling_state":
			value, err := DecodeTDLibJSONMessageSchedulingState(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field scheduling_state: %w", err)
			}
			m.SchedulingState = value
		case "is_outgoing":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field is_outgoing: %w", err)
			}
			m.IsOutgoing = value
		case "is_pinned":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field is_pinned: %w", err)
			}
			m.IsPinned = value
		case "can_be_edited":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_be_edited: %w", err)
			}
			m.CanBeEdited = value
		case "can_be_forwarded":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_be_forwarded: %w", err)
			}
			m.CanBeForwarded = value
		case "can_be_saved":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_be_saved: %w", err)
			}
			m.CanBeSaved = value
		case "can_be_deleted_only_for_self":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_be_deleted_only_for_self: %w", err)
			}
			m.CanBeDeletedOnlyForSelf = value
		case "can_be_deleted_for_all_users":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_be_deleted_for_all_users: %w", err)
			}
			m.CanBeDeletedForAllUsers = value
		case "can_get_added_reactions":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_get_added_reactions: %w", err)
			}
			m.CanGetAddedReactions = value
		case "can_get_statistics":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_get_statistics: %w", err)
			}
			m.CanGetStatistics = value
		case "can_get_message_thread":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_get_message_thread: %w", err)
			}
			m.CanGetMessageThread = value
		case "can_get_viewers":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_get_viewers: %w", err)
			}
			m.CanGetViewers = value
		case "can_get_media_timestamp_links":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_get_media_timestamp_links: %w", err)
			}
			m.CanGetMediaTimestampLinks = value
		case "can_report_reactions":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field can_report_reactions: %w", err)
			}
			m.CanReportReactions = value
		case "has_timestamped_media":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field has_timestamped_media: %w", err)
			}
			m.HasTimestampedMedia = value
		case "is_channel_post":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field is_channel_post: %w", err)
			}
			m.IsChannelPost = value
		case "is_topic_message":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field is_topic_message: %w", err)
			}
			m.IsTopicMessage = value
		case "contains_unread_mention":
			value, err := b.Bool()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field contains_unread_mention: %w", err)
			}
			m.ContainsUnreadMention = value
		case "date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field date: %w", err)
			}
			m.Date = value
		case "edit_date":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field edit_date: %w", err)
			}
			m.EditDate = value
		case "forward_info":
			if err := m.ForwardInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field forward_info: %w", err)
			}
		case "interaction_info":
			if err := m.InteractionInfo.DecodeTDLibJSON(b); err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field interaction_info: %w", err)
			}
		case "unread_reactions":
			if err := b.Arr(func(b tdjson.Decoder) error {
				var value UnreadReaction
				if err := value.DecodeTDLibJSON(b); err != nil {
					return fmt.Errorf("unable to decode message#e285e28a: field unread_reactions: %w", err)
				}
				m.UnreadReactions = append(m.UnreadReactions, value)
				return nil
			}); err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field unread_reactions: %w", err)
			}
		case "reply_to":
			value, err := DecodeTDLibJSONMessageReplyTo(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field reply_to: %w", err)
			}
			m.ReplyTo = value
		case "message_thread_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field message_thread_id: %w", err)
			}
			m.MessageThreadID = value
		case "self_destruct_time":
			value, err := b.Int32()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field self_destruct_time: %w", err)
			}
			m.SelfDestructTime = value
		case "self_destruct_in":
			value, err := b.Double()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field self_destruct_in: %w", err)
			}
			m.SelfDestructIn = value
		case "auto_delete_in":
			value, err := b.Double()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field auto_delete_in: %w", err)
			}
			m.AutoDeleteIn = value
		case "via_bot_user_id":
			value, err := b.Int53()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field via_bot_user_id: %w", err)
			}
			m.ViaBotUserID = value
		case "author_signature":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field author_signature: %w", err)
			}
			m.AuthorSignature = value
		case "media_album_id":
			value, err := b.Long()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field media_album_id: %w", err)
			}
			m.MediaAlbumID = value
		case "restriction_reason":
			value, err := b.String()
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field restriction_reason: %w", err)
			}
			m.RestrictionReason = value
		case "content":
			value, err := DecodeTDLibJSONMessageContent(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field content: %w", err)
			}
			m.Content = value
		case "reply_markup":
			value, err := DecodeTDLibJSONReplyMarkup(b)
			if err != nil {
				return fmt.Errorf("unable to decode message#e285e28a: field reply_markup: %w", err)
			}
			m.ReplyMarkup = value
		default:
			return b.Skip()
		}
		return nil
	})
}

// GetID returns value of ID field.
func (m *Message) GetID() (value int64) {
	if m == nil {
		return
	}
	return m.ID
}

// GetSenderID returns value of SenderID field.
func (m *Message) GetSenderID() (value MessageSenderClass) {
	if m == nil {
		return
	}
	return m.SenderID
}

// GetChatID returns value of ChatID field.
func (m *Message) GetChatID() (value int64) {
	if m == nil {
		return
	}
	return m.ChatID
}

// GetSendingState returns value of SendingState field.
func (m *Message) GetSendingState() (value MessageSendingStateClass) {
	if m == nil {
		return
	}
	return m.SendingState
}

// GetSchedulingState returns value of SchedulingState field.
func (m *Message) GetSchedulingState() (value MessageSchedulingStateClass) {
	if m == nil {
		return
	}
	return m.SchedulingState
}

// GetIsOutgoing returns value of IsOutgoing field.
func (m *Message) GetIsOutgoing() (value bool) {
	if m == nil {
		return
	}
	return m.IsOutgoing
}

// GetIsPinned returns value of IsPinned field.
func (m *Message) GetIsPinned() (value bool) {
	if m == nil {
		return
	}
	return m.IsPinned
}

// GetCanBeEdited returns value of CanBeEdited field.
func (m *Message) GetCanBeEdited() (value bool) {
	if m == nil {
		return
	}
	return m.CanBeEdited
}

// GetCanBeForwarded returns value of CanBeForwarded field.
func (m *Message) GetCanBeForwarded() (value bool) {
	if m == nil {
		return
	}
	return m.CanBeForwarded
}

// GetCanBeSaved returns value of CanBeSaved field.
func (m *Message) GetCanBeSaved() (value bool) {
	if m == nil {
		return
	}
	return m.CanBeSaved
}

// GetCanBeDeletedOnlyForSelf returns value of CanBeDeletedOnlyForSelf field.
func (m *Message) GetCanBeDeletedOnlyForSelf() (value bool) {
	if m == nil {
		return
	}
	return m.CanBeDeletedOnlyForSelf
}

// GetCanBeDeletedForAllUsers returns value of CanBeDeletedForAllUsers field.
func (m *Message) GetCanBeDeletedForAllUsers() (value bool) {
	if m == nil {
		return
	}
	return m.CanBeDeletedForAllUsers
}

// GetCanGetAddedReactions returns value of CanGetAddedReactions field.
func (m *Message) GetCanGetAddedReactions() (value bool) {
	if m == nil {
		return
	}
	return m.CanGetAddedReactions
}

// GetCanGetStatistics returns value of CanGetStatistics field.
func (m *Message) GetCanGetStatistics() (value bool) {
	if m == nil {
		return
	}
	return m.CanGetStatistics
}

// GetCanGetMessageThread returns value of CanGetMessageThread field.
func (m *Message) GetCanGetMessageThread() (value bool) {
	if m == nil {
		return
	}
	return m.CanGetMessageThread
}

// GetCanGetViewers returns value of CanGetViewers field.
func (m *Message) GetCanGetViewers() (value bool) {
	if m == nil {
		return
	}
	return m.CanGetViewers
}

// GetCanGetMediaTimestampLinks returns value of CanGetMediaTimestampLinks field.
func (m *Message) GetCanGetMediaTimestampLinks() (value bool) {
	if m == nil {
		return
	}
	return m.CanGetMediaTimestampLinks
}

// GetCanReportReactions returns value of CanReportReactions field.
func (m *Message) GetCanReportReactions() (value bool) {
	if m == nil {
		return
	}
	return m.CanReportReactions
}

// GetHasTimestampedMedia returns value of HasTimestampedMedia field.
func (m *Message) GetHasTimestampedMedia() (value bool) {
	if m == nil {
		return
	}
	return m.HasTimestampedMedia
}

// GetIsChannelPost returns value of IsChannelPost field.
func (m *Message) GetIsChannelPost() (value bool) {
	if m == nil {
		return
	}
	return m.IsChannelPost
}

// GetIsTopicMessage returns value of IsTopicMessage field.
func (m *Message) GetIsTopicMessage() (value bool) {
	if m == nil {
		return
	}
	return m.IsTopicMessage
}

// GetContainsUnreadMention returns value of ContainsUnreadMention field.
func (m *Message) GetContainsUnreadMention() (value bool) {
	if m == nil {
		return
	}
	return m.ContainsUnreadMention
}

// GetDate returns value of Date field.
func (m *Message) GetDate() (value int32) {
	if m == nil {
		return
	}
	return m.Date
}

// GetEditDate returns value of EditDate field.
func (m *Message) GetEditDate() (value int32) {
	if m == nil {
		return
	}
	return m.EditDate
}

// GetForwardInfo returns value of ForwardInfo field.
func (m *Message) GetForwardInfo() (value MessageForwardInfo) {
	if m == nil {
		return
	}
	return m.ForwardInfo
}

// GetInteractionInfo returns value of InteractionInfo field.
func (m *Message) GetInteractionInfo() (value MessageInteractionInfo) {
	if m == nil {
		return
	}
	return m.InteractionInfo
}

// GetUnreadReactions returns value of UnreadReactions field.
func (m *Message) GetUnreadReactions() (value []UnreadReaction) {
	if m == nil {
		return
	}
	return m.UnreadReactions
}

// GetReplyTo returns value of ReplyTo field.
func (m *Message) GetReplyTo() (value MessageReplyToClass) {
	if m == nil {
		return
	}
	return m.ReplyTo
}

// GetMessageThreadID returns value of MessageThreadID field.
func (m *Message) GetMessageThreadID() (value int64) {
	if m == nil {
		return
	}
	return m.MessageThreadID
}

// GetSelfDestructTime returns value of SelfDestructTime field.
func (m *Message) GetSelfDestructTime() (value int32) {
	if m == nil {
		return
	}
	return m.SelfDestructTime
}

// GetSelfDestructIn returns value of SelfDestructIn field.
func (m *Message) GetSelfDestructIn() (value float64) {
	if m == nil {
		return
	}
	return m.SelfDestructIn
}

// GetAutoDeleteIn returns value of AutoDeleteIn field.
func (m *Message) GetAutoDeleteIn() (value float64) {
	if m == nil {
		return
	}
	return m.AutoDeleteIn
}

// GetViaBotUserID returns value of ViaBotUserID field.
func (m *Message) GetViaBotUserID() (value int64) {
	if m == nil {
		return
	}
	return m.ViaBotUserID
}

// GetAuthorSignature returns value of AuthorSignature field.
func (m *Message) GetAuthorSignature() (value string) {
	if m == nil {
		return
	}
	return m.AuthorSignature
}

// GetMediaAlbumID returns value of MediaAlbumID field.
func (m *Message) GetMediaAlbumID() (value int64) {
	if m == nil {
		return
	}
	return m.MediaAlbumID
}

// GetRestrictionReason returns value of RestrictionReason field.
func (m *Message) GetRestrictionReason() (value string) {
	if m == nil {
		return
	}
	return m.RestrictionReason
}

// GetContent returns value of Content field.
func (m *Message) GetContent() (value MessageContentClass) {
	if m == nil {
		return
	}
	return m.Content
}

// GetReplyMarkup returns value of ReplyMarkup field.
func (m *Message) GetReplyMarkup() (value ReplyMarkupClass) {
	if m == nil {
		return
	}
	return m.ReplyMarkup
}
